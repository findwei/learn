[TOC]


# 类的修饰符

- Java类和类之间的关系

    继承   关联   依赖

- Java面向对象的四个特征

    继承(extends)   封装   多态   (抽象)


>修饰符主要就是为了封装

    封装 : 将一些数据或执行过程  进行一个包装  
    目的 : 保护这些数据 或 执行过程的安全
            方法本身就算是封装   封装了执行的过程  保护过程的安全  隐藏了执行细节   增强复用性
            类也算是一个封装  好多的方法和属性---->类   
            对属性本身的封装:
                属性私有(封装在类中)
                提供操作属性相应的方式(公有的方法)
                强烈建议 属性不要公有的---->非常不安全
                这样操作属性  属性及其操作属性的方法都有其命名的规约 使用setName getName 来修改与获取
                age------>    setAge        getAge
                myAge-->    setMyAge   getMyAge

```java
// 这样操作属性  属性及其操作属性的方法都有其命名的规约 使用setName getName 来修改与获取 更加安全
public class Cs {
    private int age;

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }
}
                
```
             
```java

//  权限修饰符 特征修饰符 class  类名{
//      属性	权限  特征  类型  名字
//	    方法	权限  特征  返回值  名字  参数  异常  执行体
//	    构造方法	权限  名字  参数  异常  执行体
//	    程序块	执行体
//  }

```
## 权限修饰符

**那么权限修饰符号能修饰什么**

	权限修饰符可以用来修饰  类本身、和类中的成员 (除程序块)
    
	权限修饰符用来修饰类的时候只有两个可以用(public  默认不写)

| 修饰符名称 | 修饰符权限                                                              |
| :--------- | ----------------------------------------------------------------------- |
| public     | 公共的	在本类、同包 、子类 、当前项目中任意类的位置只要有对象都可以访问 |
| protected  | 受保护的   在本类、同包 、子类(**通过子类对象在子类范围内部访问**)      |
| 默认不写   | 默认的 同包                                                             |
| private    | 私有的               本类                                               |





## 特征修饰符

| 特征修饰符名称 | 特征修饰符                  |
| :------------- | --------------------------- |
| final          | 最终的  不可更改的          |
| static         | 静态的                      |
| abstract       | 抽象的                      |
| native         | 本地的                      |
| *transient     | 瞬时的  短暂的------>序列化 |
| *synchronized  | 同步的	线程问题             |
| *volatile      | 不稳定的                    |

1. final   最终的   不可更改的

    - 修饰`变量`

        如果在定义变量时没有赋初始值 给变量一次存值的机会(因为变量在栈内存空间内 没有默认值 如果不给机会 就没法用啦)

        一旦变量被存储了一个值 若用final修饰后 则不让再次改变 ----> 相当于常量啦(值没法动)

        **注意变量类型是基本类型还是引用类型**
        
        如果修饰的变量是基本数据类型  则变量内的值不让更改---常量

        如果修饰的变量是引用数据类型  则变量内的 `地址引用` 不让更改---对象唯一 对象里面的值存在堆内存是可以更改的

    - 修饰`属性`
  
        全局变量  存储在堆内存的对象空间内一个空间 属性如果没有赋值  有默认值存在的

        属性用final修饰后  必须给属性赋初值  否则编译报错

        特点与修饰变量一致  **注意变量类型是基本类型还是引用类型**

        如果修饰的变量是基本数据类型  则变量内的值不让更改---常量

        如果修饰的变量是引用数据类型  则变量内的 `地址引用` 不让更改---对象唯一

    - 修饰`方法`
    
        方法是最终的方法  不可更改

        final修饰的方法  要求**不可以被子类重写**(覆盖)

    - 修饰`类本身`
  
        类是最终的 不可以更改

        (太监类 无后) 此类不可以被其他子类继承 

        通常都是一些定义好的工具类 例如：`Math`   `Scanner`   `Integer`   `String`

2. static静态的
   
    ![继承在内存中的存储形式](https://cdn.jsdelivr.net/gh/findwei/learnImages@main/java/objectAdvance/内存结构简图.png)

    > **注意不能修饰变量**
   
	- 可以修饰 ： 修饰`属性`   修饰`方法`   `*修饰块`    `修饰类(内部类)`
  
	- 特点：
  
		1. 静态元素在`类加载时就初始化`啦，创建的非常早，此时没有创建对象 
		2. 静态元素存储在静态元素区中，`每一个类有一个自己的区域`，与别的类不冲突
		3. 静态元素`只加载一次`(只有一份)，同一个类模板的`类对象及类本身共享`
		4. 由于静态元素区加载的时候，有可能没有创建对象，可以通过`类名字直接访问`
		5. 可以理解为静态元素不属于任何一个对象，`属于类`的
		6. 静态元素区Garbage Collection(垃圾回收器)无法管理，可以粗暴的认为常驻内存 （tips:栈内存使用完成自己马上销毁，堆内存使用Garbage Collection(垃圾回收器)）
		7. 非静态成员(堆内存对象里)中可以访问静态成员(静态区)
		8. 静态成员中可以访问静态成员(都存在静态区)
		9.  静态成员中不可以访问非静态成员(个数 一个出发访问一堆相同名字的东西 说不清)(静态元素属于类 非静态成员属于对象自己)
		10. 静态元素中不可以出现this或super关键字(静态元素属于类)



