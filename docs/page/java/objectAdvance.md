[TOC]


# 类的关系与继承

## 类和类之间的关系

    A is-a  B  =>  泛化(继承   实现)例如：人是动物,人和动物是继承的关系 
    A has-a B  =>  包含(组合   聚合   关联)例如：人有眼睛,人和眼睛是聚合的关系
    A use-a B  =>  依赖(依赖)  (need-a) 

## 继承(is-a)

1. 子类继承父类，通过一个关键字 `extends`
2. 子类的对象可以调用父类中的(public protected)属性和方法
3. 子类可以添加自己独有的属性和方法的
4. 子类从父类中继承过来的属性、方法不能满足子类需要，可以在子类中重写(覆盖)父类的属性、方法
5. 每一个类都有继承类，如果不写`extends`关键字，默认继承`Object`，如果写了`extends`则继承后面那个父类，`Object`是任何一个引用类型的父类(直接或间接的继承Object),Object类没有父类
6. Java中继承是单个存在的(**单继承**)  每一个类只能有一个继承类  (在extends关键字后面只能写一个类) 但是可以通过传递的方式实现多继承的效果  后续还会有多实现
7. **继承在内存中的存储形式**
   
   这里可以按照下面图标理解 实际上面申请的空间是一个
   ![继承在内存中的存储形式](https://cdn.jsdelivr.net/gh/findwei/learnImages@main/java/objectAdvance/继承关系存储.jpg)
8. **关于this和super的使用**
   
    - `this`和`super`都是指代词  代替的是对象

    - `this`代替的是当前执行方法时的那个对象  不一定是当前类的(因为谁调用`this`指向谁)
    
    - `super`代替的是当前执行方法时的对象的父类对象  空间内部的那个

    - `this`和`super`都能调用一般属性 和 一般方法

    - 可以放置在类成员的任意位置(属性 方法 构造 块) **注意调用一般方法的时候可以来回互相调用(写法 编译好用) 执行可能产生问题(StackOverflowError)**
       
    - 可以调用构造方法(**放在构造方法的第一行**)
  
        `this`和`super`在构造方法中调用另一个类的构造方法不能同时出现在第一行
        
        **构造方法之间不能来回互相调用**(编译就不好用)

--------------------------------------------------------------------

|   /    | 方法重写override                                                                                                                                       | 方法重载overload                               |
| :----: | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------- |
|   类   | 产生两个继承关系的类 - 子类重写父类的方法                                                                                                              | 一个类中的一组方法                             |
|  名字  | 子类与父类一致                                                                                                                                         | 一个类中的好多方法名必须一致                   |
|  参数  | 子类与父类一致                                                                                                                                         | 每一个方法的参数必须**不一致**(个数 类型 顺序) |
| 返回值 | 子类可以**小于等于**父类                                                                                                                               | 没有要求                                       |
|  权限  | 子类可以**大于等于**父类                                                                                                                               | 没有要求                                       |
|  特征  | final:父类方法是final   子类不能重写 <br /> static:父类方法是static  子类不存在 <br /> abstract:父类方法是abstract  子类必须重写                       | 没有要求                                       |
|  异常  | 运行时:父类方法抛出运行时异常,子类可以不予理会  <br/>  编译时:如果父类方法抛出编译时异常,子类抛出异常的个数少于等于父类,子类抛出异常的类型小于等于父类 | 没有要求                                       |
| 方法体 | 子类的方法内容与父类不一致                                                                                                                             | 每一个重载的方法 执行过程不一致                |

-------------------------------------------------------

**小细节知识点补充**

Object类中的方法

  - hashCode() 将对象在内存中的地址经过计算得到一个int整数 (public native int hashCode()=>native修饰符表明该方法是本机方法（用Java以外的语言实现）)
          
  - equals() 用来比较两个对象的内容  Object默认效果是==

    ==可以比较基本类型(比较值) 可以比较引用类型(比较地址)

    equals方法时Object类中继承过来的方法  默认效果比较地址  

    如果想要改变其规则 可以进行方法重写
    ```java 
    public boolean equals(Object obj){
        return (this == obj);
    }
          ```
  - toString() 打印输出时将对象变成String字符串
  
    ```java
    public String toString(){
        return this.getClass().getName()+"@"+Integer.toHexString(this.hashCode());
    }
    ```
  - getClass() 获取对象对应类的类映射(反射)
  - wait() 线程进入挂起等待状态	存在方法重载
  - notify() 线程唤醒
  - notifyAll() 唤醒所有
  - finalize() 权限修饰符是protected  在对象被GC回收的时候  默认调用执行的方法(类似c++里面的析构函数)
  - clone()	权限修饰符是protected  为了克隆对象





