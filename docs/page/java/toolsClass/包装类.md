# 包装类(封装类)

在Java中，包装类（Wrapper Class）是用来将**基本数据类型**转换为对象的类。Java提供了一组包装类，每个基本数据类型对应一个包装类，用于在需要对象的上下文中使用基本数据类型。包装类提供了一些方法来操作基本数据类型的值。

为了解决基本数据类型不能使用面向对象的思想

**1.5版本之后自动拆装包**

Java 的基本数据类型及其对应的包装类8个：
- byte---Byte   
- short---Short   
- int---Integer  
- long---Long
- float---Float  
- double---Double  
- char---Character   
- boolean---Boolean

1. 八个包装类都在同一个包（java.lang包）下，不需要import导包直接使用
2. 八个包装类中有六个是与数字相关，都默认继承父类Number
   ```java
    //例如：Integer的继承关系
    //java.lang.Object
    //    java.lang.Number
    //        java.lang.Integer
   ```
3. 八个包装类都实现了Serializable, Comparable
4. 八个包装类都有带自己对应类型参数的构造方法，并且八个包装类中有七个(除了Character外)还有带String类型构造方法重载
5. 创建对象  对象调用方法  xxxValue();  将一个包装类类型转化为对应的基本类型(拆包)
   
    ```java
    Integer i1 = new Integer(10);//引用数据类型 包装类
    int value = i1.intValue();

    Integer i2 = 10;
    int value = new Integer(10);

    int value = Integer.parseInt("123");	Float.parseFloat("123.45")
    int value = new Integer("123");

    ```


## 经常在笔试中出现的问题

```java
Integer ii1 = 128;
Integer ii2 = 128;
Integer i1 = 10;//这里在-128-127的范围
Integer i2 = 10;//这里在-128-127的范围 取的缓存 这里的i1和i2是用一个 Interger
Integer i3 = new Integer(10);
Integer i4 = new Integer(10);
System.out.println(ii1==ii2);//  false--->原因见下面
System.out.println(i1==i2);//  true---> 原因见下面
System.out.println(i1==i3);//  false
System.out.println(i3==i4);//  false
System.out.println(ii1.equals(ii2));//true
System.out.println(i1.equals(i2));//true
System.out.println(i1.equals(i3));//true
System.out.println(i3.equals(i4));//true
```
![包装类对象存储结构](https://cdn.jsdelivr.net/gh/findwei/learnImages@main/java/toolsClass/包装类对象存储结构.png)

1. ==与equals()区别(equals继承自Object,但是这里Integer重写了equals)

   - == 可以比较基本数据类型  也可以比较引用数据类型  (变量中存储的内容，变量在栈内存)
        - 如果比较基本类型比较是变量中存储的值
        - 如果比较引用类型比较是变量中存储的地址引用（就是比较栈内存中存的值，变量就是存在栈内存中，引用数据内存赋值给变量的时候栈内存里面存的是引用数据的地址引用）
   - equals()是Object类中继承过来的方法  每一个引用类型都可以调用
   - 默认继承的equals()方法比较与==一致  如果想要改变比较规则 可以重写equals方法
   - 由于Integer类就重写了equals() 所以Integer比较的是数值

2. Integer类加载的时候  自己有一个静态的空间
    - 空间内立即加载 Integer类型的数组  内存储256个Integer对象   -128 ~ 127
    - 如果我们用的对象范围在这之内Integer i1 = 10;  直接取静态区中找对应的对象
    - 如果我们用的对象范围超出了这个Integer i1 = 1000;  会帮我们创建一个新的Integer对象

Interger.java上面部分源码如下：

```java
// Interger.java
// 重写equals
    /**
     * Compares this object to the specified object.  The result is
     * {@code true} if and only if the argument is not
     * {@code null} and is an {@code Integer} object that
     * contains the same {@code int} value as this object.
     *
     * @param   obj   the object to compare with.
     * @return  {@code true} if the objects are the same;
     *          {@code false} otherwise.
     */
    public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
    }

// 获取当前值
    /**
     * Returns the value of this {@code Integer} as an
     * {@code int}.
     */
    @IntrinsicCandidate
    public int intValue() {
        return value;
    }

// valueOf
    /**
     * Returns an {@code Integer} instance representing the specified
     * {@code int} value.  If a new {@code Integer} instance is not
     * required, this method should generally be used in preference to
     * the constructor {@link #Integer(int)}, as this method is likely
     * to yield significantly better space and time performance by
     * caching frequently requested values.
     *
     * This method will always cache values in the range -128 to 127,
     * inclusive, and may cache other values outside of this range.
     *
     * @param  i an {@code int} value.
     * @return an {@code Integer} instance representing {@code i}.
     * @since  1.5
     */
    @IntrinsicCandidate
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }

// -128-127 这个范围的缓存 这也是导致上面结果System.out.println(ii1==ii2);System.out.println(i1==i2); 结果不一样的问题
    /**
     * Cache to support the object identity semantics of autoboxing for values between
     * -128 and 127 (inclusive) as required by JLS.
     *
     * The cache is initialized on first usage.  The size of the cache
     * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.
     * During VM initialization, java.lang.Integer.IntegerCache.high property
     * may be set and saved in the private system properties in the
     * jdk.internal.misc.VM class.
     *
     * WARNING: The cache is archived with CDS and reloaded from the shared
     * archive at runtime. The archived cache (Integer[]) and Integer objects
     * reside in the closed archive heap regions. Care should be taken when
     * changing the implementation and the cache array should not be assigned
     * with new Integer object(s) after initialization.
     */
    private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer[] cache;
        static Integer[] archivedCache;

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    h = Math.max(parseInt(integerCacheHighPropValue), 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(h, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            // Load IntegerCache.archivedCache from archive, if possible
            CDS.initializeFromArchive(IntegerCache.class);
            int size = (high - low) + 1;

            // Use the archived cache if it exists and is large enough
            if (archivedCache == null || size > archivedCache.length) {
                Integer[] c = new Integer[size];
                int j = low;
                for(int i = 0; i < c.length; i++) {
                    c[i] = new Integer(j++);
                }
                archivedCache = c;
            }
            cache = archivedCache;
            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }

```            
